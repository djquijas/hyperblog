Esta es la historia de Diego Quijas.
Diego Quijas nació de Mexico y tiene 29 años

Ya no se que poner.

Hoy hablaremos de su historia.

git init = inicia el lugar de trabajo de git
git status = Muestra el status de los archivos
git add . = Agrega todos los archivos al stage
git add <archivo> = Agrega un archivo en especifico al stage
git rm --cached <archivo> = Elimina el archivo del stage
git log <archivo> = Muestra el historial de los commit
git commit -m "Mensaje" = Hace un commit a los archivos que se agregaron al stage
git show <archivo> = Muestra los cambios que ha tenido el archivo en comparacion del ultimo git
                     con el git anterior.
git diff <id1> <id2> = Muestra las diferencias entre dos commits .
git reset <id> --hard = Regresa a la version anterior que se selecciono, eliminando todo lo antenrior
git reset <id> --soft = Regresa a la version anterrior que se selecciono, pero dejando en staging lo que se tenia
git checkout <id> <archivo.name> = Regresa a la version seleccionada, y elimina lo anterior hasta que se
                                   realiza un commit.

git rm --force: Elimina los archivos de Git y del disco duro. 
                Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, 
                de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).

git reset
Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.

Este comando es muy peligroso y debemos emplearlo solo en caso de emergencia. Recuerda que debemos usar alguna de estas dos opciones:

Hay dos formas de utilizar git reset: con el argumento --hard, borrando toda la información que tengamos en el área de staging (y perdiendo todo para siempre). 
                                      O, un poco más seguro, con el argumento --soft, que mantiene allí los archivos del área de staging para que podamos aplicar 
                                      nuestros últimos cambios pero desde un commit anterior.

git reset --soft: Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.
git reset --hard: Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging se borra del historial.
¡Pero todavía falta algo!

git reset HEAD: Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, 
                a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.

Despues de hacer git log, y el resultado sea muy grande, para salir se tiene que orpimir "q"

git commit -am "mensaje" = Se utiliza para hacer automaticamente el add y commit en la misma linea

git branch <nombre> = Crea nueva rama de trabajo
git checkout <nombre rama> = Se cambia a la rama que se necesite
git branch = Muestra las ramas que existen
git merge <branch> = Fuciona las ramas, en la que estas actualmente y la que eliges
git remote add origin <direccion repositorio> = Agrega el repositorio Git a un repositorio remoto (GitHub)
git remote =
git remote -v =
git push origin master = envia al origen lo que contiene master
git pull origin master = trae al master el contenido del origen
git remote set-url origin <link> = cambia el origen del repositorio remoto

git log --all --decorate --graph --oneline = Muestra todos los commits hechos comprimidos y graficamente

alias <nombre>="comando git" : Crea un alias para comando largos, y los guarda
git tag -a <version que quieras> -m "mensaje" <hash donde se actualizara>
git show-ref --tags = Muestra el hash que hace referencia al tag
git push --tags = Envia los tags a GitHub
git tag -d <nombre del tag> = Elimina un tag (Solo lo elimina en Git)
git push origin :refs/tags/<nombre del tag> (Elimina el tag en GitHub)
git show-branch --all
git show-branch
gitk = Abre en un software las ramas que se han creado y sus commits+git clone <link> = clona un repositorio de GitHub
git clone <link> = Clona un repositorio de GitHub en el repositorio local
git config -l = Muestra las configuraciones de Git en el entorno local
git log --graph = Muestra en forma de grafica los logs
git log --stat =

Entidades HTML

Los archivos binarios (imagenes), datos de la API, o de la base de datos, no se deben subir a GIT o 
GitHub, se deben guardar en un archivo con nombre .gitignore en la raiz del proyecto.
Para indicar que ignore todos los archivos .jpg es: *.jpg

readme.md (md = markdown) En el archivo readme se puede agregar html
git rebase <nombre del branch> = Hace cambios en el repositorio sin dejar rastros (Es una mala practica utilizarlo y puede causar problemas)
                                 Si se utiliza, tienes que estar en la rama secundaria y traer lo que contiene main.
                                 Despues se pasa a la rama main y se trae lo que contiene la rama secundaria.

git stash = Guarda los cambios en algun lado, y te regresa a la ultima version que tenias antes de dichos cambios
git stash list = Muestra la lista de los stash
git stash branch <nombre del branch> = Crea otro branch con lo guardado en el stash 
git stash pop = Regresa los cambios hechos a la rama principaldrop
git stash drop = Elimina los datos guardado en el stash, y no genera cambios

Stashed:
El stashed nos sirve para guardar cambios para después, Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de rama sin perder el trabajo que todavía no guardamos en un commit

Ésto es especialmente útil porque hay veces que no se permite cambiar de rama, ésto porque porque tenemos cambios sin guardar, no siempre es un cambio lo suficientemente bueno como para hacer un commit, pero no queremos perder ese código en el que estuvimos trabajando.

El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, más adelante, retomar el trabajo con los archivos que teníamos en Staging pero que podemos recuperar ya que los guardamos en el Stash.

git stash
El comando git stash guarda el trabajo actual del Staging en una lista diseñada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.

git clean --dry-run = Muestra los archivos no deseados que eliminara, pueden ser archivos copiados
git clean -f = Eimina los archivos
Este comando no elimina carpetas solo archivos, tampoco elimina archivos en .gitignore

git cherry-pick <id log> = Te permite escoger un cambio en una rama secundaria y llevartela a la rama principal

Git nunca olvida, git reflog
Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que estás haciendo sólo es actualizar la punta del branch, para gestionar éstas puntas existe un mecanismo llamado registros de referencia o reflogs.
.
La gestión de estos cambios es mediante los hash’es de referencia (o ref) que son apuntadores a los commits.
.
Los recoges registran cuándo se actualizaron las referencias de Git en el repositorio local (sólo en el local), por lo que si deseas ver cómo has modificado la historia puedes utilizar el comando:
git reflog

git commit --amend = Agrega los cambios hechos que no se mandaron al commit. 
                     Es un comando para corregir si se olvido hacer un en el commit anterior. Primero se tiene que hacer un git add
                     al archivo donde se hizo el cambio.

git grep <Palabra a buscar> = Busca una palabra dentro de los archivos de los documentos
git grep color -->use la palabra color
git grep la --> donde use la palabra la
git grep -n color–> en que lineas use la palabra color
git grep -n platzi --> en que lineas use la palabra platzi
git grep -c la --> cuantas veces use la palabra la
git grep -c paltzi --> cuantas veces use la palabra platzi
git grep -c “<p>”–> cuantas veces use la etiqueta <p>

git log-S “cabecera” --> cuantas veces use la palabra cabecera en
todos los commits.

grep–> para los archivos
log --> para los commits.

git shortlog -sn = muestra cuantos commit han hecho cada miembros del equipo.
git shortlog -sn --all = muestra cuantos commit han hecho cada miembros del equipo hasta los que han sido eliminado
git shortlog -sn --all --no-merge = muestra cuantos commit han hecho cada miembros quitando los eliminados sin los merges
git blame ARCHIVO = muestra quien hizo cada cosa linea por linea
git COMANDO --help = muestra como funciona el comando.
git blame ARCHIVO -Llinea_inicial,linea_final= muestra quien hizo cada cosa linea por linea indicándole desde que linea ver ejemplo -L35,50
**git branch -r **= se muestran todas las ramas remotas
git branch -a = se muestran todas las ramas tanto locales como remotas